set nocompatible
filetype off

" general options ------------------------------------------------ {{{
set encoding=utf-8
scriptencoding utf-8

set autoindent
set background=dark
set backspace=indent,eol,start

" yank to system clipboard
set clipboard+=unnamed

" keep vim from asking you to hit Enter all the time
set cmdheight=2

set completeopt-=preview

" only conceal text in normal mode
set concealcursor=n
set conceallevel=0
set cursorline

" use vertical splits for diff mode
set diffopt+=vertical

" put all swap files in a central location
set directory=$CACHEDIR/vim/swap

" make vertical split bar solid
set fillchars+=vert:\│

set foldlevelstart=1
set foldmethod=marker
set grepformat=%f:%l:%m
set hidden
set hlsearch
set ignorecase
set incsearch
set laststatus=2
set listchars+=precedes:^,extends:$
set modelines=1
set nobackup
set nocompatible

" don't insert 2 spaces after periods when joining lines
set nojoinspaces

" don't move to the start of a line when jumping (like with Ctrl-F)
set nostartofline
set nowrap
set nowritebackup

" don't treat numbers starting with a 0 as octal
set nrformats-=octal
set number
set omnifunc=syntaxcomplete#Complete
set scrolloff=5
set shiftwidth=4
set showcmd
set smartcase
set smarttab
set tabstop=4

" put all undo files in a central location
set undodir=~/.cache/vim/undo

" check a bit more frequently
set updatetime=2000

" use undo files for persistent undo
set undofile
set virtualedit=
set visualbell

" make find more useful
set wildignore+=*.pyc,*.obj,*.bin
set wildmenu
set path=**
" }}}

" leader mappings ------------------------------------------------ {{{
let g:mapleader=";"

map <Leader>f :find 

" <leader>w to write
map <silent> <Leader>w :w<CR>
map <silent> <Leader>W :w!<CR>

" <leader>q to quit
map <silent> <Leader>q :q<CR>
map <silent> <Leader>Q :q!<CR>

" <leader>c to close a file
map <silent> <Leader>c :Bd<CR>
map <silent> <Leader>C :bd<CR>

" highlight the cursor column for alignment help
map <silent> <Leader>hc :set cursorcolumn!<CR>
map <silent> <Leader>hl :set cursorline!<CR>

" make ctrl-q always close the location list
map <silent> ctrl-q :lclose<CR>

" toggle paste mode
map <silent> <Leader>v :set paste!<CR>

" alternate redraw since C-L is taken
map <leader>r :redraw!<CR>

" bind ctrl-n and ctrl-p to step through location list results
map <silent> <C-N> :cn<CR>
map <silent> <C-P> :cp<CR>
" }}}

" intialize the autocommand group for vimrc-defined autocommands
augroup vimrc
	autocmd!
augroup END

" == Plugins =================================================

call plug#begin('~/.vim/plugged')

Plug '1995eaton/vim-better-javascript-completion', { 'for': [ 'javascript', 'html' ] }
Plug 'AndrewRadev/linediff.vim'
Plug 'AndrewRadev/splitjoin.vim'
Plug 'SirVer/ultisnips', { 'on': [] }
Plug 'Shougo/vimproc.vim', { 'do': 'make' }
Plug 'Textile-for-VIM', { 'for': 'textile' }
Plug 'a.vim'
Plug 'applescript.vim', { 'for': 'applescript' }
Plug 'benekastah/neomake', { 'on': [] }
Plug 'christoomey/vim-tmux-navigator'
Plug 'clausreinke/typescript-tools.vim', { 'for': 'typescript', 'do': 'npm -g install clausreinke/typescript-tools' }
Plug 'elzr/vim-json', { 'for': 'json' }
Plug 'groenewege/vim-less', { 'for': 'less' }
Plug 'gregsexton/gitv'
Plug 'gorkunov/smartpairs.vim'
Plug 'hail2u/vim-css3-syntax', { 'for': [ 'css', 'html' ] }
Plug 'honza/vim-snippets', { 'on': [] }
Plug 'itchyny/lightline.vim'
Plug 'leafgarland/typescript-vim', { 'for': 'typescript' }
Plug 'jason0x43/vim-colors-solarized'
Plug 'jason0x43/vim-js-indent', { 'for':  [ 'javascript', 'typescript', 'html' ] }
Plug 'jason0x43/vim-js-syntax', { 'for':  [ 'javascript', 'html' ] }
" Start tagbar for go files so vim-go can inject golang support
Plug 'majutsushi/tagbar', { 'on': 'TagbarToggle', 'for': [ 'go' ] }
Plug 'junegunn/vim-easy-align'
Plug 'marijnh/tern_for_vim', { 'for': [ 'javascript', 'html' ] }
Plug 'mbbill/undotree', { 'on': 'UndotreeToggle' }
Plug 'moll/vim-bbye'
Plug 'niklasl/vim-rdf'
Plug 'rking/ag.vim'
Plug 'scrooloose/nerdtree', { 'on': 'NERDTreeToggle' }
" Plug 'scrooloose/syntastic', { 'on': [] }
" Plug 'sickill/vim-pasta'
Plug 'suy/vim-context-commentstring'
Plug 'tfnico/vim-gradle'
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-markdown', { 'for': 'markdown' }
Plug 'tpope/vim-obsession'
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-surround'
Plug 'dhruvasagar/vim-prosession'
Plug 'vim-coffee-script', { 'for': 'coffeescript' }
Plug 'vim-tmuxify'
Plug 'wavded/vim-stylus', { 'for': 'stylus' }
Plug 'tpope/vim-vinegar'
Plug 'Valloric/YouCompleteMe'

if executable('go')
	Plug 'fatih/vim-go', { 'for': 'go' }
	let g:go_fmt_command = "goimports"
	let g:go_auto_type_info = 1
endif
call plug#end()

" fzf fuzzy finder; FZF_PATH is set via zshrc, and uses the vim files from the
" homebrew install of fzf
if executable('fzf') && $FZF_PATH != "" && !has("gui_running")
	set rtp+=$FZF_PATH

	" maintain a list of active buffers, sorted by most-recently-used
	let s:fzf_buffers = []

	function! FzfBufEntered()
		" move the current buffer to the top of the list
		let l:name = resolve(expand("<afile>"))
		if name != "" && name !~ "NERD_tree_.*" && &buftype == ''
			let l:i = index(s:fzf_buffers, name)
			if i != -1
				call remove(s:fzf_buffers, i)
			endif
			let s:fzf_buffers = insert(s:fzf_buffers, name)
		endif
	endfunction

	function! FzfBufDeleted()
		" remove the buffer being deleted from the list
		let l:name = resolve(expand("<afile>"))
		if name != ""
			let l:idx = index(s:fzf_buffers, name)
			if idx != -1
				call remove(s:fzf_buffers, idx)
			endif
		endif
	endfunction

	augroup fzfbuf
		autocmd!
		autocmd BufAdd,BufEnter * call FzfBufEntered()
		autocmd BufDelete * call FzfBufDeleted()
	augroup END

	function! s:editfile(filename)
		execute "split " . a:filename
		wincmd p
		wincmd q
	endfunction

	function! s:editbuffer(filename)
		execute "sbuffer " . a:filename
		wincmd p
		wincmd q
	endfunction

	command! FZFFiles call fzf#run({
		\'sink' : function("<sid>editfile"),
		\'down' : 8,
		\})
	command! FZFBuffers call fzf#run({
		\'source': s:fzf_buffers,
		\'sink' : function("<sid>editbuffer"),
		\'down' : 8,
		\})
	command! FZFGit call fzf#run({
		\'source': 'git ls-tree -r --name-only HEAD',
		\'sink' : function("<sid>editfile"),
		\'options' : '-m',
		\'down' : 8,
		\})

	let g:fzf_tmux_height=15
	map <Leader>f :FZFFiles<CR>
	" map <Leader>f :FZF<CR>
	map <Leader>b :FZFBuffers<CR>
	map <Leader>g :FZFGit<CR>
endif

" a -------------------------------------------------------------- {{{
let g:alternateExtensions_coffee = 'js'
let g:alternateExtensions_styl = 'css'
let g:alternateExtensions_css = 'styl'
let g:alternateExtensions_ts = 'js'
let g:alternateExtensions_js = 'ts'
" }}}

" airline -------------------------------------------------------- {{{
let g:airline_left_sep=''
let g:airline_right_sep=''
let g:airline_section_warning=''
let g:airline_section_z='%p%% %l %c'
let g:airline#extensions#tabline#formatter = 'unique_tail'
" }}}

" bookmarks ------------------------------------------------------ {{{
let g:simple_bookmarks_filename = expand('$CACHEDIR~/vim/bookmarks')
let g:simple_bookmarks_signs = 1
let g:simple_bookmarks_sign_text = '>'
" }}}

" easy-align ----------------------------------------------------- {{{
map <silent> <Leader>a <Plug>(EasyAlign)
" }}}

" indentLine ----------------------------------------------------- {{{
let g:indentLine_enabled = 0
let g:indentLine_char = '┊'
let g:indentLine_color_term = 236

" show or hide indent guide lines
function! ToggleIndentGuides()
	if &expandtab
		IndentLinesToggle
	else
		if &list
			set nolist
		else
			set list lcs=tab:\┊\ 
		endif
	endif
endfunction
command! ToggleIndentGuides call ToggleIndentGuides()

map <silent> <Leader>ig :ToggleIndentGuides<CR>
" }}}

" javascript ----------------------------------------------------- {{{
let g:html_indent_script1 = 'inc'
let g:html_indent_style1 = 'inc'
let g:js_indent_flat_switch = 1
" }}}

" json ----------------------------------------------------------- {{{
let g:vim_json_syntax_conceal = 0
" }}}

" lightline ------------------------------------------------------ {{{
let g:lightline = {
	\ 'colorscheme': 'solarized',
	\ 'active': {
	\   'left': [ [ 'mode', 'paste' ], [ 'fugitive', 'filename' ] ],
	\   'right': [ [ 'lineinfo' ], ['percent'], [ 'fileformat', 'fileencoding', 'filetype' ] ]
	\ },
	\ 'component': {
	\   'absolutepath': '%F',
	\   'bufnum': '%n',
	\   'charvalue': '%b',
	\   'charvaluehex': '%B',
	\   'close': '%999X X ',
	\   'column': '%c',
	\   'fileencoding': '%{strlen(&fenc)?&fenc:&enc}',
	\   'fileformat': '%{&fileformat}',
	\   'filename': '%t',
	\   'filetype': '%{strlen(&filetype)?&filetype:"no ft"}',
	\   'line': '%l',
	\   'lineinfo': '%l:%v',
	\   'mode': '%{lightline#mode()}',
	\   'modified': '%M',
	\   'paste': '%{&paste?"PASTE":""}',
	\   'percent': '%p%%',
	\   'percentwin': '%P',
	\   'readonly': '%R',
	\   'relativepath': '%f',
	\   'spell': '%{&spell?&spelllang:"no spell"}'
	\ },
	\ 'component_function': {
	\   'fugitive': 'LightlineFugitive',
	\   'filename': 'LightlineFilename',
	\   'fileformat': 'LightlineFileformat',
	\   'filetype': 'LightlineFiletype',
	\   'fileencoding': 'LightlineFileencoding',
	\   'mode': 'LightlineMode',
	\ },
	\ 'subseparator': { 'left': '│', 'right': '│' }
	\ }

function! LightlineModified()
  return &ft =~ 'help' ? '' : &modified ? '+' : &modifiable ? '' : '-'
endfunction

function! LightlineReadonly()
  return &ft !~? 'help' && &readonly ? 'RO' : ''
endfunction

function! LightlineFilename()
  let fname = expand('%:t')
  return fname == 'ControlP' ? g:lightline.ctrlp_item :
	  \ fname == '__Tagbar__' ? 'TagBar' :
	  \ fname =~ '__Gundo\|NERD_tree' ? '' :
	  \ &ft == 'vimfiler' ? vimfiler#get_status_string() :
	  \ &ft == 'unite' ? unite#get_status_string() :
	  \ &ft == 'vimshell' ? vimshell#get_status_string() :
	  \ ('' != LightlineReadonly() ? LightlineReadonly() . ' ' : '') .
	  \ ('' != fname ? fname : '[No Name]') .
	  \ ('' != LightlineModified() ? ' ' . LightlineModified() : '')
endfunction

function! LightlineFugitive()
	try
		if expand('%:t') !~? 'Tagbar\|Gundo\|NERD' && &ft !~? 'vimfiler' && exists('*fugitive#head')
			let l:mark = ''  " edit here for cool mark
			let l:_ = fugitive#head()
			return strlen(_) ? mark._ : ''
		endif
	catch
	endtry
	return ''
endfunction

function! LightlineFileformat()
	return winwidth(0) > 70 ? &fileformat : ''
endfunction

function! LightlineFiletype()
	return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
endfunction

function! LightlineFileencoding()
	return winwidth(0) > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
endfunction

function! LightlineMode()
	let fname = expand('%:t')
	return fname == '__Tagbar__' ? 'Tagbar' :
		\ fname == 'ControlP' ? 'CtrlP' :
		\ fname == '__Gundo__' ? 'Gundo' :
		\ fname == '__Gundo_Preview__' ? 'Gundo Preview' :
		\ fname =~ 'NERD_tree' ? 'NERDTree' :
		\ &ft == 'unite' ? 'Unite' :
		\ &ft == 'vimfiler' ? 'VimFiler' :
		\ &ft == 'vimshell' ? 'VimShell' :
		\ winwidth(0) > 60 ? lightline#mode() : ''
endfunction

let g:ctrlp_status_func = {
	\   'main': 'LightlineCtrlPStatus_1',
	\   'prog': 'LightlineCtrlPStatus_2',
	\ }

function! LightlineCtrlPStatus_1(focus, byfname, regex, prev, item, next, marked)
	let g:lightline.ctrlp_regex = a:regex
	let g:lightline.ctrlp_prev = a:prev
	let g:lightline.ctrlp_item = a:item
	let g:lightline.ctrlp_next = a:next
	return lightline#statusline(0)
endfunction

function! LightlineCtrlPStatus_2(str)
	return lightline#statusline(0)
endfunction

function! LightlineRefresh()
	if !exists('g:loaded_lightline')
		return
	endif
	let g:lightline.colorscheme = 'solarized_' . &background
	call lightline#init()
	call lightline#colorscheme()
	call lightline#update()
endfunction
command! LightlineRefresh :call LightlineRefresh()
" }}}

" neomake -------------------------------------------------------- {{{
augroup load_neomake
	autocmd!
	autocmd BufRead * call NeomakeInit()
	autocmd BufWrite * call NeomakeInit()
augroup END
function! NeomakeInit()
	autocmd! load_neomake
	call plug#load('neomake')

	let g:neomake_go_maker = neomake#makers#ft#go#go()
	" let g:neomake_go_enabled_makers = ['golint']
	let g:neomake_go_enabled_makers = []

	" let g:neomake_open_list = 1
	let g:neomake_error_sign = {
				\ 'text': '>>',
				\ 'texthl': 'NeomakeError',
				\ }
	let g:neomake_warning_sign = {
				\ 'text': '>>',
				\ 'texthl': 'NeomakeWarning',
				\ }

	let g:neomake_tsc_maker = {
				\ 'errorformat': '%E%f(%l\,%c): error %m'
				\ }
	let g:neomake_typescript_tslint_maker = {
				\ 'exe': 'tslint',
				\ 'args': [ '-f' ],
				\ 'errorformat': '%W%f[%l\, %c]: %m'
				\ }
	let g:neomake_typescript_enabled_makers = [ 'tslint' ]

	autocmd vimrc BufWritePost *.ts Neomake! tsc
	autocmd vimrc BufWritePost *.go Neomake! go
endfunction

" This function is called by UpdateBackground to ensure that
" the Neomake styles are refreshed whenever the color scheme
" is updated.
function! NeomakeRefresh()
	if &background == 'dark'
		hi NeomakeError ctermfg=1 ctermbg=0 cterm=bold
		hi NeomakeWarning ctermfg=3 ctermbg=0 cterm=bold
	else
		hi NeomakeError ctermfg=1 ctermbg=7 cterm=bold
		hi NeomakeWarning ctermfg=3 ctermbg=7 cterm=bold
	endif
endfunction
command! NeomakeRefresh :call NeomakeRefresh()

" }}}

" NERDTree ------------------------------------------------------- {{{
let g:NERDTreeHijackNetrw = 0
let g:NERDTreeMinimalUI   = 1
" disable C-K and C-J mappings; wasn't using, and they break tmux-navigator
let g:NERDTreeMapJumpPrevSibling = ''
let g:NERDTreeMapJumpNextSibling = ''
map <silent> <Leader>e :NERDTreeToggle<CR>
" }}}

" netrw ---------------------------------------------------------- {{{
" don't load gitignore rules until netrw is actually loaded the first time
let g:netrw_home = expand('$CACHEDIR/vim/')
" default to tree listing
let g:netrw_liststyle = 3
augroup netrw
	autocmd!
	autocmd FileType netrw call NetrwInit()
augroup END
function! NetrwInit()
	autocmd! netrw
	if exists('g:loaded_vinegar')
		let g:netrw_list_hide=join([g:netrw_list_hide, netrw_gitignore#Hide()], ',')
	endif
endfunction
" }}}

" prosession ----------------------------------------------------- {{{
let g:prosession_dir = expand('$CACHEDIR/vim/session/')
" }}}

" solarized ------------------------------------------------------ {{{
let g:solarized_italic = 1
let g:solarized_terms_italic = ['iTerm.app']
let g:solarized_menu = 0
" }}}

" syntastic ------------------------------------------------------ {{{
" let g:syntastic_java_javac_config_file_enabled = 1
" let g:syntastic_coffee_checkers = ['coffeelint', 'coffee']
" let g:syntastic_html_tidy_ignore_errors = [
"       \ 'lacks "action" attribute',
"       \ "'<' + '/' + letter not allowed here",
"       \	]
" let g:syntastic_loc_list_height = 3
" " let g:syntastic_typescript_tsc_args = '--module amd --noImplicitAny'
" let g:syntastic_typescript_checkers = ['tsc', 'tslint']
" let g:syntastic_typescript_tslint_args = '-c ~/.tslintrc'
" let g:syntastic_css_csslint_args = '--ignore=ids,adjoining-classes'
" let g:syntastic_javascript_checkers = ['jshint', 'jscs']

" map <silent> <Leader>nc :SyntasticCheck<CR>
" map <silent> <Leader>ne :Errors<CR>

" augroup load_syn
" 	autocmd!
" 	autocmd BufRead * call SynInit()
" 	autocmd BufWrite * call SynInit()
" augroup END
" function! SynInit()
" 	autocmd! load_syn
" 	call plug#load('syntastic')
" endfunction
" }}}

" Tagbar --------------------------------------------------------- {{{
map <silent> <Leader>t :TagbarToggle<CR>
" }}}

" tern ----------------------------------------------------------- {{{
let g:tern_show_signature_in_pum = 1
" }}}

" typescript ----------------------------------------------------- {{{
let g:TSSshowErrors = 0
command! TSSkeymap call TSSkeymap()
" }}}

" undotree ------------------------------------------------------- {{{
nnoremap <Leader>u :UndotreeToggle<CR>
" }}}

" UltiSnips ------------------------------------------------------ {{{
let g:UltiSnipsExpandTrigger = "<c-k>"
augroup load_us
	autocmd!
	autocmd InsertEnter * call plug#load('ultisnips', 'vim-snippets') | autocmd! load_us
augroup END
" }}}

" == End plugins =============================================

" use a better grep ---------------------------------------------- {{{
if executable('ag')
	" Use The Silver Searcher https://github.com/ggreer/the_silver_searcher
	set grepprg=ag\ --nogroup\ --nocolor
elseif executable('ack')
	" use ack
	set grepprg=ack\ -a
endif
" }}}

" show changes in a buffer since it was opened ------------------- {{{
command! DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis
	\ | wincmd p | diffthis
" }}}

" always go to the last accessed line when a file is opened ------ {{{
autocmd vimrc BufReadPost *
	\ if line("'\"") > 1 && line("'\"") <= line("$") |
	\   exe "normal! g`\"" |
	\ endif
" }}}

" better navigation when line wrapping is on --------------------- {{{
function! ToggleWrap()
	if &wrap
		echo "Wrap OFF"
		setlocal nowrap
		silent! nunmap <buffer> k
		silent! nunmap <buffer> j
		silent! nunmap <buffer> 0
		silent! nunmap <buffer> $
	else
		echo "Wrap ON"
		setlocal wrap linebreak nolist
		setlocal display+=lastline
		map <buffer> <silent> k gk
		map <buffer> <silent> j gj
		map <buffer> <silent> 0 g0
		map <buffer> <silent> $ g$
	endif
endfunction
command! ToggleWrap call TogglWrap()
" }}}

" toggle conceal mode -------------------------------------------- {{{
map <silent> <Leader>o :call ConcealToggle()<CR>
function! ConcealToggle()
	if &conceallevel
		setlocal conceallevel=0
	else
		setlocal conceallevel=2
	endif
endfunction
" }}}

" make escape leave insert mode immediately ---------------------- {{{
if ! has('gui_running')
	set ttimeoutlen=10
	augroup FastEscape
		autocmd!
		autocmd InsertEnter * set timeoutlen=0
		autocmd InsertLeave * set timeoutlen=1000
	augroup END
endif
" }}}

" show the syntax status of the character under the cursor ------- {{{
map <silent> <Leader>h :echo "hi<" . 
	\ synIDattr(synID(line("."),col("."),1),"name") 
	\ . '> trans<'
	\ . synIDattr(synID(line("."),col("."),0),"name") . "> lo<"
	\ . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"<CR>
" }}}

" more accurate syntax highlighting
autocmd vimrc BufEnter * :syntax sync fromstart

" highlight columns past 80
"let &colorcolumn=join(range(81,999), ",")

" load the builting matchit plugin
runtime! macros/matchit.vim

" set random filetypes
autocmd vimrc BufRead .jscsrc set filetype=json
autocmd vimrc BufRead .tslintrc set filetype=json
autocmd vimrc BufRead *.textile set filetype=textile
autocmd vimrc BufRead *.dashtoc set filetype=json

" update the background if a termbg file exists
function! RefreshColors()
	let l:termbg = expand('$CACHEDIR/termbg')
	if filereadable(termbg)
		let l:lines=readfile(termbg)
		if lines[0] == 'light'
			set background=light
		else
			set background=dark
		endif
	endif
	LightlineRefresh
	NeomakeRefresh
endfunction
command! RefreshColors call RefreshColors()

filetype plugin indent on | syntax on

colorscheme solarized

" process the termbg file if one exists
call RefreshColors()

" vim:tabstop=4:shiftwidth=4:noexpandtab
