#
# A simple theme that displays relevant, contextual information.
#
# This is a modified version of Sorin's theme from prezto.
#

# Prints the first non-empty string in the arguments array
function coalesce {
	for arg in $argv; do
		print "$arg"
		return 0
	done
	return 1
}

# Exposes information about the Zsh Line Editor via the $editor_info associative
# array.
function editor-info {
	# Clean up previous $editor_info.
	unset editor_info
	typeset -gA editor_info

	if [[ "$KEYMAP" == 'vicmd' ]]; then
		zstyle -s ':zconf:module:editor:info:keymap:alternate' format 'REPLY'
		editor_info[keymap]="$REPLY"
	else
		zstyle -s ':zconf:module:editor:info:keymap:primary' format 'REPLY'
		editor_info[keymap]="$REPLY"

		if [[ "$ZLE_STATE" == *overwrite* ]]; then
			zstyle -s ':zconf:module:editor:info:keymap:primary:overwrite' format 'REPLY'
			editor_info[overwrite]="$REPLY"
		else
			zstyle -s ':zconf:module:editor:info:keymap:primary:insert' format 'REPLY'
			editor_info[overwrite]="$REPLY"
		fi
	fi

	unset REPLY

	zle reset-prompt
	zle -R
}
zle -N editor-info

# Updates editor information when the keymap changes.
function zle-keymap-select {
	zle editor-info
}
zle -N zle-keymap-select

# Enables terminal application mode and updates editor information.
function zle-line-init {
	# The terminal must be in application mode when ZLE is active for $terminfo
	# values to be valid.
	if (( $+terminfo[smkx] )); then
		# Enable terminal application mode.
		echoti smkx
	fi

	# Update editor information.
	zle editor-info
}
zle -N zle-line-init

# Disables terminal application mode and updates editor information.
function zle-line-finish {
	# The terminal must be in application mode when ZLE is active for $terminfo
	# values to be valid.
	if (( $+terminfo[rmkx] )); then
		# Disable terminal application mode.
		echoti rmkx
	fi

	# Update editor information.
	zle editor-info
}
zle -N zle-line-finish

# Toggles emacs overwrite mode and updates editor information.
function overwrite-mode {
	zle .overwrite-mode
	zle editor-info
}
zle -N overwrite-mode

# Enters vi insert mode and updates editor information.
function vi-insert {
	zle .vi-insert
	zle editor-info
}
zle -N vi-insert

# Moves to the first non-blank character then enters vi insert mode and updates
# editor information.
function vi-insert-bol {
	zle .vi-insert-bol
	zle editor-info
}
zle -N vi-insert-bol

# Enters vi replace mode and updates editor information.
function vi-replace  {
	zle .vi-replace
	zle editor-info
}
zle -N vi-replace

# Expands .... to ../..
function expand-dot-to-parent-directory-path {
	if [[ $LBUFFER = *.. ]]; then
		LBUFFER+='/..'
	else
		LBUFFER+='.'
	fi
}
zle -N expand-dot-to-parent-directory-path

# Displays an indicator when completing.
function expand-or-complete-with-indicator {
	local indicator
	zstyle -s ':zconf:module:editor:info:completing' format 'indicator'
	print -Pn "$indicator"
	zle expand-or-complete
	zle redisplay
}
zle -N expand-or-complete-with-indicator

# Inserts 'sudo ' at the beginning of the line.
function prepend-sudo {
	if [[ "$BUFFER" != su(do|)\ * ]]; then
		BUFFER="sudo $BUFFER"
		(( CURSOR += 5 ))
	fi
}
zle -N prepend-sudo

# Checks a boolean variable for "true".
# Case insensitive: "1", "y", "yes", "t", "true", "o", and "on".
function is-true {
	[[ -n "$1" && "$1" == (1|[Yy]([Ee][Ss]|)|[Tt]([Rr][Uu][Ee]|)|[Oo]([Nn]|)) ]]
}

# Git repo information
function _git-dir {
	local git_dir="${$(git rev-parse --git-dir):A}"
	if [[ -n "$git_dir" ]]; then
		print "$git_dir"
		return 0
	else
		print "$0: not a repository: $PWD" >&2
		return 1
	fi
}

# Gets the Git special action (am, bisect, cherry, merge, rebase).
# Borrowed from vcs_info and edited.
function _git-action {
	local action_dir
	local git_dir="$(_git-dir)"
	local apply_formatted
	local bisect_formatted
	local cherry_pick_formatted
	local cherry_pick_sequence_formatted
	local merge_formatted
	local rebase_formatted
	local rebase_interactive_formatted
	local rebase_merge_formatted

	for action_dir in \
		"${git_dir}/rebase-apply" \
		"${git_dir}/rebase" \
		"${git_dir}/../.dotest"
	do
		if [[ -d "$action_dir" ]] ; then
			zstyle -s ':zconf:module:git:info:action:apply' format 'apply_formatted' || apply_formatted='apply'
			zstyle -s ':zconf:module:git:info:action:rebase' format 'rebase_formatted' || rebase_formatted='rebase'

			if [[ -f "${action_dir}/rebasing" ]] ; then
				print "$rebase_formatted"
			elif [[ -f "${action_dir}/applying" ]] ; then
				print "$apply_formatted"
			else
				print "${rebase_formatted}/${apply_formatted}"
			fi

			return 0
		fi
	done

	for action_dir in \
		"${git_dir}/rebase-merge/interactive" \
		"${git_dir}/.dotest-merge/interactive"
	do
		if [[ -f "$action_dir" ]]; then
			zstyle -s ':zconf:module:git:info:action:rebase-interactive' format 'rebase_interactive_formatted' || rebase_interactive_formatted='rebase-interactive'
			print "$rebase_interactive_formatted"
			return 0
		fi
	done

	for action_dir in \
		"${git_dir}/rebase-merge" \
		"${git_dir}/.dotest-merge"
	do
		if [[ -d "$action_dir" ]]; then
			zstyle -s ':zconf:module:git:info:action:rebase-merge' format 'rebase_merge_formatted' || rebase_merge_formatted='rebase-merge'
			print "$rebase_merge_formatted"
			return 0
		fi
	done

	if [[ -f "${git_dir}/MERGE_HEAD" ]]; then
		zstyle -s ':zconf:module:git:info:action:merge' format 'merge_formatted' || merge_formatted='merge'
		print "$merge_formatted"
		return 0
	fi

	if [[ -f "${git_dir}/CHERRY_PICK_HEAD" ]]; then
		if [[ -d "${git_dir}/sequencer" ]] ; then
			zstyle -s ':zconf:module:git:info:action:cherry-pick-sequence' format 'cherry_pick_sequence_formatted' || cherry_pick_sequence_formatted='cherry-pick-sequence'
			print "$cherry_pick_sequence_formatted"
		else
			zstyle -s ':zconf:module:git:info:action:cherry-pick' format 'cherry_pick_formatted' || cherry_pick_formatted='cherry-pick'
			print "$cherry_pick_formatted"
		fi

		return 0
	fi

	if [[ -f "${git_dir}/BISECT_LOG" ]]; then
		zstyle -s ':zconf:module:git:info:action:bisect' format 'bisect_formatted' || bisect_formatted='bisect'
		print "$bisect_formatted"
		return 0
	fi

	return 1
}

# Gets the Git status information.
function git-info {
	# Extended globbing is needed to parse repository status.
	setopt LOCAL_OPTIONS
	setopt EXTENDED_GLOB

	local action
	local action_format
	local action_formatted
	local added=0
	local added_format
	local added_formatted
	local ahead=0
	local ahead_and_behind
	local ahead_and_behind_cmd
	local ahead_format
	local ahead_formatted
	local ahead_or_behind
	local behind=0
	local behind_format
	local behind_formatted
	local branch
	local branch_format
	local branch_formatted
	local branch_info
	local clean
	local clean_formatted
	local commit
	local commit_format
	local commit_formatted
	local deleted=0
	local deleted_format
	local deleted_formatted
	local dirty=0
	local dirty_format
	local dirty_formatted
	local ignore_submodules
	local indexed=0
	local indexed_format
	local indexed_formatted
	local -A info_formats
	local info_format
	local modified=0
	local modified_format
	local modified_formatted
	local position
	local position_format
	local position_formatted
	local remote
	local remote_cmd
	local remote_format
	local remote_formatted
	local renamed=0
	local renamed_format
	local renamed_formatted
	local stashed=0
	local stashed_format
	local stashed_formatted
	local status_cmd
	local status_mode
	local unindexed=0
	local unindexed_format
	local unindexed_formatted
	local unmerged=0
	local unmerged_format
	local unmerged_formatted
	local untracked=0
	local untracked_format
	local untracked_formatted

	# Clean up previous $git_info
	unset git_info
	typeset -gA git_info

	# Return if not inside a Git repository work tree
	if ! is-true "$(git rev-parse --is-inside-work-tree 2> /dev/null)"; then
		return 1
	fi

	if (( $# > 0 )); then
		if [[ "$1" == [Oo][Nn] ]]; then
			git config --bool prompt.showinfo true
		elif [[ "$1" == [Oo][Ff][Ff] ]]; then
			git config --bool prompt.showinfo false
		else
			print "usage: $0 [ on | off ]" >&2
		fi
		return 0
	fi

	# Return if git-info is disabled
	if ! is-true "${$(git config --bool prompt.showinfo):-true}"; then
		return 1
	fi

	# Ignore submodule status
	zstyle -s ':zconf:module:git:status:ignore' submodules 'ignore_submodules'

	# Format commit
	zstyle -s ':zconf:module:git:info:commit' format 'commit_format'
	if [[ -n "$commit_format" ]]; then
		commit="$(git rev-parse HEAD 2> /dev/null)"
		if [[ -n "$commit" ]]; then
			zformat -f commit_formatted "$commit_format" "c:$commit"
		fi
	fi

	# Format stashed
	zstyle -s ':zconf:module:git:info:stashed' format 'stashed_format'
	if [[ -n "$stashed_format" && -f "$(_git-dir)/refs/stash" ]]; then
		stashed="$(git stash list 2> /dev/null | wc -l | awk '{print $1}')"
		if [[ -n "$stashed" ]]; then
			zformat -f stashed_formatted "$stashed_format" "S:$stashed"
		fi
	fi

	# Format action
	zstyle -s ':zconf:module:git:info:action' format 'action_format'
	if [[ -n "$action_format" ]]; then
		action="$(_git-action)"
		if [[ -n "$action" ]]; then
			zformat -f action_formatted "$action_format" "s:$action"
		fi
	fi

	# Get the branch
	branch="${$(git symbolic-ref HEAD 2> /dev/null)#refs/heads/}"

	# Format branch
	zstyle -s ':zconf:module:git:info:branch' format 'branch_format'
	if [[ -n "$branch" && -n "$branch_format" ]]; then
		zformat -f branch_formatted "$branch_format" "b:$branch"
	fi

	# Format position
	zstyle -s ':zconf:module:git:info:position' format 'position_format'
	if [[ -z "$branch" && -n "$position_format" ]]; then
		position="$(git describe --contains --all HEAD 2> /dev/null)"
		if [[ -n "$position" ]]; then
			zformat -f position_formatted "$position_format" "p:$position"
		fi
	fi

	# Format remote
	zstyle -s ':zconf:module:git:info:remote' format 'remote_format'
	if [[ -n "$branch" && -n "$remote_format" ]]; then
		# Gets the remote name.
		remote_cmd='git rev-parse --symbolic-full-name --verify HEAD@{upstream}'
		remote="${$(${(z)remote_cmd} 2> /dev/null)##refs/remotes/}"
		if [[ -n "$remote" ]]; then
			zformat -f remote_formatted "$remote_format" "R:$remote"
		fi
	fi

	zstyle -s ':zconf:module:git:info:ahead' format 'ahead_format'
	zstyle -s ':zconf:module:git:info:behind' format 'behind_format'
	if [[ -n "$branch" && ( -n "$ahead_format" || -n "$behind_format" ) ]]; then
		# Gets the commit difference counts between local and remote
		ahead_and_behind_cmd='git rev-list --count --left-right HEAD...@{upstream}'

		# Get ahead and behind counts
		ahead_and_behind="$(${(z)ahead_and_behind_cmd} 2> /dev/null)"

		# Format ahead
		if [[ -n "$ahead_format" ]]; then
			ahead="$ahead_and_behind[(w)1]"
			if (( ahead > 0 )); then
				zformat -f ahead_formatted "$ahead_format" "A:$ahead"
			fi
		fi

		# Format behind
		if [[ -n "$behind_format" ]]; then
			behind="$ahead_and_behind[(w)2]"
			if (( behind > 0 )); then
				zformat -f behind_formatted "$behind_format" "B:$behind"
			fi
		fi
	fi

	# Get status type.
	if ! zstyle -t ':zconf:module:git:info' verbose; then
		# Format indexed.
		zstyle -s ':zconf:module:git:info:indexed' format 'indexed_format'
		if [[ -n "$indexed_format" ]]; then
			((
				indexed+=$(
					git diff-index \
						--no-ext-diff \
						--name-only \
						--cached \
						--ignore-submodules=${ignore_submodules:-none} \
						HEAD \
						2> /dev/null \
						| wc -l
				)
			))
			if (( indexed > 0 )); then
				zformat -f indexed_formatted "$indexed_format" "i:$indexed"
			fi
		fi

		# Format unindexed.
		zstyle -s ':zconf:module:git:info:unindexed' format 'unindexed_format'
		if [[ -n "$unindexed_format" ]]; then
			((
				unindexed+=$(
					git diff-files \
						--no-ext-diff \
						--name-only \
						--ignore-submodules=${ignore_submodules:-none} \
						2> /dev/null \
						| wc -l
				)
			))
			if (( unindexed > 0 )); then
				zformat -f unindexed_formatted "$unindexed_format" "I:$unindexed"
			fi
		fi

		# Format untracked.
		zstyle -s ':zconf:module:git:info:untracked' format 'untracked_format'
		if [[ -n "$untracked_format" ]]; then
			((
				untracked+=$(
					git ls-files \
						--other \
						--exclude-standard \
						2> /dev/null \
						| wc -l
				)
			))
			if (( untracked > 0 )); then
				zformat -f untracked_formatted "$untracked_format" "u:$untracked"
			fi
		fi

		(( dirty = indexed + unindexed + untracked ))
	else
		# Use porcelain status for easy parsing.
		status_cmd="git status --porcelain --ignore-submodules=${ignore_submodules:-none}"

		# Get current status
		while IFS=$'\n' read line; do
			# Count added, deleted, modified, renamed, unmerged, untracked, dirty.
			# T (type change) is undocumented, see http://git.io/FnpMGw.
			# For a table of scenarii, see http://i.imgur.com/2YLu1.png.
			[[ "$line" == ([ACDMT][\ MT]|[ACMT]D)\ * ]] && (( added++ ))
			[[ "$line" == [\ ACMRT]D\ * ]] && (( deleted++ ))
			[[ "$line" == ?[MT]\ * ]] && (( modified++ ))
			[[ "$line" == R?\ * ]] && (( renamed++ ))
			[[ "$line" == (AA|DD|U?|?U)\ * ]] && (( unmerged++ ))
			[[ "$line" == \?\?\ * ]] && (( untracked++ ))
			(( dirty++ ))
		done < <(${(z)status_cmd} 2> /dev/null)

		# Format added
		if (( added > 0 )); then
			zstyle -s ':zconf:module:git:info:added' format 'added_format'
			zformat -f added_formatted "$added_format" "a:$added"
		fi

		# Format deleted
		if (( deleted > 0 )); then
			zstyle -s ':zconf:module:git:info:deleted' format 'deleted_format'
			zformat -f deleted_formatted "$deleted_format" "d:$deleted"
		fi

		# Format modified
		if (( modified > 0 )); then
			zstyle -s ':zconf:module:git:info:modified' format 'modified_format'
			zformat -f modified_formatted "$modified_format" "m:$modified"
		fi

		# Format renamed
		if (( renamed > 0 )); then
			zstyle -s ':zconf:module:git:info:renamed' format 'renamed_format'
			zformat -f renamed_formatted "$renamed_format" "r:$renamed"
		fi

		# Format unmerged
		if (( unmerged > 0 )); then
			zstyle -s ':zconf:module:git:info:unmerged' format 'unmerged_format'
			zformat -f unmerged_formatted "$unmerged_format" "U:$unmerged"
		fi

		# Format untracked
		if (( untracked > 0 )); then
			zstyle -s ':zconf:module:git:info:untracked' format 'untracked_format'
			zformat -f untracked_formatted "$untracked_format" "u:$untracked"
		fi
	fi

	# Format dirty and clean
	if (( dirty > 0 )); then
		zstyle -s ':zconf:module:git:info:dirty' format 'dirty_format'
		zformat -f dirty_formatted "$dirty_format" "D:$dirty"
	else
		zstyle -s ':zconf:module:git:info:clean' format 'clean_formatted'
	fi

	# Format info
	zstyle -a ':zconf:module:git:info:keys' format 'info_formats'
	for info_format in ${(k)info_formats}; do
		zformat -f REPLY "$info_formats[$info_format]" \
			"a:$added_formatted" \
			"A:$ahead_formatted" \
			"B:$behind_formatted" \
			"b:$branch_formatted" \
			"C:$clean_formatted" \
			"c:$commit_formatted" \
			"d:$deleted_formatted" \
			"D:$dirty_formatted" \
			"i:$indexed_formatted" \
			"I:$unindexed_formatted" \
			"m:$modified_formatted" \
			"p:$position_formatted" \
			"R:$remote_formatted" \
			"r:$renamed_formatted" \
			"s:$action_formatted" \
			"S:$stashed_formatted" \
			"U:$unmerged_formatted" \
			"u:$untracked_formatted"
		git_info[$info_format]="$REPLY"
	done

	unset REPLY
	return 0
}

# Max prompt with before we start compressing things
MAX_WIDTH=30

# Format the PWD
function prompt_jason_pwd {
	local pwd="${PWD/#$HOME/~}"

	if [[ "$pwd" == (#m)[/~] ]]; then
		_prompt_jason_pwd="$MATCH"
			unset MATCH
	else
		_prompt_jason_pwd="${${${(@j:/:M)${(@s:/:)pwd}##.#?}:h}%/}/${pwd:t}"

		if (( ${#_prompt_jason_pwd} >= $MAX_WIDTH )); then
			_prompt_jason_pwd="${pwd:t}"
		fi

		if (( ${#_prompt_jason_pwd} >= $MAX_WIDTH )); then
			_prompt_jason_pwd=".../${_prompt_jason_pwd[0,30]}..."
		fi
	fi
}

# Run commands to generate info required for the prompt
function prompt_jason_precmd {
	setopt LOCAL_OPTIONS
	unsetopt XTRACE KSH_ARRAYS

	# Format PWD.
	prompt_jason_pwd

	# Get Git repository information.
	if (( $+functions[git-info] )); then
		git-info
	fi

	# Get Python information
	if (( $+functions[python-info] )); then
		python-info
	fi
}

# Actually build the prompt
function prompt_jason_setup {
	setopt LOCAL_OPTIONS
	unsetopt XTRACE KSH_ARRAYS
	prompt_opts=(cr percent subst)

	# Load required functions.
	autoload -Uz add-zsh-hook

	# Add hook for calling git-info before each command.
	add-zsh-hook precmd prompt_jason_precmd

	# Set editor-info parameters.
	zstyle ':zconf:module:editor:info:completing' format '%B%F{red}...%f%b'
	zstyle ':zconf:module:editor:info:keymap:primary' format ' %B%F{red}❯%F{yellow}❯%F{green}❯%f%b'
	zstyle ':zconf:module:editor:info:keymap:primary:overwrite' format ' %F{red}♺%f'
	zstyle ':zconf:module:editor:info:keymap:alternate' format ' %B%F{green}❮%F{yellow}❮%F{red}❮%f%b'

	# Set git-info parameters.
	zstyle ':zconf:module:git:info' verbose 'yes'
	zstyle ':zconf:module:git:info:action' format ':%%B%F{yellow}%s%f%%b'
	zstyle ':zconf:module:git:info:added' format ' %%B%F{green}✚%f%%b'
	zstyle ':zconf:module:git:info:ahead' format ' %%B%F{yellow}⬆%f%%b'
	zstyle ':zconf:module:git:info:behind' format ' %%B%F{yellow}⬇%f%%b'
	zstyle ':zconf:module:git:info:branch' format ':%F{green}%b%f'
	zstyle ':zconf:module:git:info:commit' format ':%F{green}%.7c%f'
	zstyle ':zconf:module:git:info:deleted' format ' %%B%F{red}✖%f%%b'
	zstyle ':zconf:module:git:info:modified' format ' %%B%F{orange}✱%f%%b'
	zstyle ':zconf:module:git:info:position' format ':%F{red}%p%f'
	zstyle ':zconf:module:git:info:renamed' format ' %%B%F{magenta}➜%f%%b'
	zstyle ':zconf:module:git:info:stashed' format ' %%B%F{cyan}✭%f%%b'
	zstyle ':zconf:module:git:info:unmerged' format ' %%B%F{yellow}═%f%%b'
	zstyle ':zconf:module:git:info:untracked' format ' %%B%F{white}◼%f%%b'
	zstyle ':zconf:module:git:info:keys' format \
		'prompt' ' %F{blue}git%f$(coalesce "%b" "%p" "%c")%s' \
		'rprompt' '%A%B%S%a%d%m%r%U%u'

	zstyle ':zconf:module:python:info:virtualenv' format '[%v] '

	# Define prompts.
	PROMPT='%F{25}$python_info[virtualenv]%F{60}${SSH_TTY:+%n@%m }%F{cyan}${_prompt_jason_pwd}%f${git_info:+${(e)git_info[prompt]}}%(!. %B%F{red}#%f%b.)${editor_info[keymap]} '
	RPROMPT='${editor_info[overwrite]}%(?:: %F{red}⏎%f)${VIM:+" %B%F{green}V%f%b"}${git_info[rprompt]}'
	SPROMPT='zsh: correct %F{red}%R%f to %F{green}%r%f [nyae]? '
}

prompt_jason_setup "$@"

# vim:filetype=zsh:shiftwidth=4:tabstop=4:noexpandtab
