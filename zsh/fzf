if (( ! $+commands[fzf] )); then
	# exit if this system doesn't have fzf
	return
fi

# Setup fzf ############################################################

if [[ -z "$FZF_DEFAULT_OPTS" ]]; then
	export FZF_DEFAULT_OPTS=--no-color
fi

export FZF_PATH=`echo $(which fzf)(:A:h:h)`

# Completion ###########################################################

# This doesn't work well with autosuggestions at the moment
# [[ $- =~ i ]] && source $FZF_PATH/shell/completion.zsh

# Key bindings #########################################################

[[ $- =~ i ]] && source $FZF_PATH/shell/key-bindings.zsh

bindkey '^P' fzf-file-widget
bindkey '^G' fzf-cd-widget

# Useful functions #####################################################

# fkill - kill a process
function fkill() {
	local pid
	pid=$(ps -ef | sed 1d | fzf -e -m | awk '{print $2}')
	if [ -n "$pid" ]; then
		kill -${1:-TERM} $pid
	fi
}

# fvi - load file in vim
function fvi() {
	local file
	file=$(fzf)
	if [ -n "$file" ]; then
		vi $file
	fi
}

# fbr - checkout git branch
fbr() {
  local branches branch
  branches=$(git branch --all | grep -v HEAD) &&
  branch=$(echo "$branches" |
           fzf-tmux -d $(( 2 + $(wc -l <<< "$branches") )) +m) &&
  git checkout $(echo "$branch" | sed "s/.* //" | sed "s#remotes/[^/]*/##")
}

# fco - checkout git branch/tag
fco() {
  local tags branches target
  tags=$(
    git tag | awk '{print "\x1b[31;1mtag\x1b[m\t" $1}') || return
  branches=$(
    git branch --all | grep -v HEAD             |
    sed "s/.* //"    | sed "s#remotes/[^/]*/##" |
    sort -u          | awk '{print "\x1b[34;1mbranch\x1b[m\t" $1}') || return
  target=$(
    (echo "$tags"; echo "$branches") |
    fzf-tmux -l30 -- --no-hscroll --ansi +m -d "\t" -n 2) || return
  git checkout $(echo "$target" | awk '{print $2}')
}

# fshow - git commit browser (enter for show, ctrl-d for diff, ` toggles sort)
fshow() {
  local out shas sha q k
  while out=$(
      git log --graph --color=always \
          --format="%C(auto)%h%d %s %C(black)%C(bold)%cr" "$@" |
      fzf --ansi --multi --no-sort --reverse --query="$q" --tiebreak=index \
          --print-query --expect=ctrl-d --toggle-sort=\`); do
    q=$(head -1 <<< "$out")
    k=$(head -2 <<< "$out" | tail -1)
    shas=$(sed '1,2d;s/^[^a-z0-9]*//;/^$/d' <<< "$out" | awk '{print $1}')
    [ -z "$shas" ] && continue
    if [ "$k" = 'ctrl-d' ]; then
      git diff --color=always $shas | less -R
    else
      for sha in $shas; do
        git show --color=always $sha | less -R
      done
    fi
  done
}

# vim:filetype=zsh:shiftwidth=4:tabstop=4:noexpandtab:foldmethod=marker
