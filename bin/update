#!/usr/bin/env python3

import asyncio
from argparse import ArgumentParser
from typing import Callable, Dict, List, Optional, Tuple, cast, Any
from collections import namedtuple
from os import getenv, environ
from pathlib import Path
from curses import setupterm, tparm, tigetstr, tigetnum
from sys import stdout, argv
from abc import ABC, abstractmethod


Env = Dict[str, str]
StatusUpdater = Callable[[str], None]
Versions = namedtuple("Versions", ["local", "remote"])
Package = namedtuple("Package", ["name", "previous", "current"])
Updates = namedtuple("Updates", ["name", "packages"])
statuses: List[str] = []

num_cols = 0
progress_width = 20
progress_format = "[%%-%d.%ds]" % (progress_width, progress_width)


class Updater(ABC):
    status_updater: Any
    name: str
    progress_max: int

    def __init__(self, name: str):
        self.name = name
        self.status_updater = add_status(name, "Updating...")
        self.progress_count = 0

    def update_status(self, msg: str):
        cast(StatusUpdater, self.status_updater)(msg)

    def update_progress(self, count: int, extra: Optional[str] = None):
        progress = "#" * int(progress_width * (count / self.progress_max))
        status = f"[{progress:{progress_width}.{progress_width}}]"
        if extra:
            status = f"{status} {extra}"
        self.update_status(status)

    async def update_packages(self):
        updates = await self.check_packages()

        updated: List[Package] = []
        packages = updates.packages

        if len(packages) > 0:
            self.progress_max = len(packages)

            for i, pkg in enumerate(packages):
                self.update_progress(i, f"{pkg.name}...")
                if await self.update_package(pkg.name):
                    updated.append(pkg)

        self.update_status("Done")
        return Updates(self.name, updated)

    @abstractmethod
    async def check_packages(self) -> Updates:
        pass

    @abstractmethod
    async def update_package(self, name: str) -> None:
        pass


class Output:
    raw_stdout: Optional[bytes]
    raw_stderr: Optional[bytes]
    str_stdout: Optional[str]
    str_stderr: Optional[str]
    exitcode: int

    def __init__(
        self, exitcode: int, raw_stdout: Optional[bytes], raw_stderr: Optional[bytes]
    ):
        self.exitcode = exitcode
        self.raw_stdout = raw_stdout
        self.raw_stderr = raw_stderr
        self.str_stdout = None
        self.str_stderr = None

    @property
    def stdout(self):
        if self.raw_stdout != None and self.str_stdout == None:
            self.str_stdout = self.raw_stdout.decode("utf-8").rstrip()
        return self.str_stdout

    @property
    def stderr(self):
        if self.raw_stderr != None and self.str_stderr == None:
            self.str_stderr = self.raw_stderr.decode("utf-8").rstrip()
        return self.str_stderr


class GitUpdater(Updater):
    packages_path: Path
    name: str

    def __init__(self, name: str, packages_path: Path):
        super().__init__(name)
        self.name = name
        self.packages_path = packages_path

    async def check_package(self, pkg_dir: Path) -> Optional[Package]:
        cwd = self.packages_path / pkg_dir

        await run("git fetch -q", cwd=cwd)
        (branch_out, head_out) = await asyncio.gather(
            *[
                run("git branch --show-current", cwd=cwd),
                run("git rev-parse HEAD", cwd=cwd),
            ]
        )
        branch = branch_out.stdout
        head = head_out.stdout[:8]

        remote_head = (await run(f"git rev-parse origin/{branch}", cwd=cwd)).stdout[:8]

        (tag_out, remote_tag_out) = await asyncio.gather(
            *[
                run(f"git describe {head}", cwd=cwd),
                run(f"git describe {remote_head}", cwd=cwd),
            ]
        )
        tag = tag_out.stdout
        remote_tag = remote_tag_out.stdout

        tag_str = f" ({tag})" if tag != "" else ""
        remote_tag_str = f" ({remote_tag})" if tag != "" else ""

        local_version = f"{head}{tag_str}"
        remote_version = f"{remote_head}{remote_tag_str}"

        return (
            Package(pkg_dir.name, local_version, remote_version)
            if local_version != remote_version
            else None
        )

    async def check_packages(self) -> Updates:
        self.update_status("Checking for outdated packages...")
        needs_update: List[Package] = []

        if self.packages_path != None:
            packages = await asyncio.gather(
                *[
                    self.check_package(p)
                    for p in [f for f in self.packages_path.iterdir() if f.is_dir()]
                ]
            )
            needs_update = [p for p in packages if p != None]

        self.update_status("Done")
        return Updates(self.name, needs_update)

    async def update_package(self, pkg_name: str):
        cwd = self.packages_path / pkg_name
        out1 = await run("git pull -q --recurse-submodules", cwd=cwd)
        if out1.exitcode == 0:
            out2 = await run("git submodule update --remote", cwd=cwd)
        return out1.exitcode + out2.exitcode == 0


class PythonUpdater(Updater):
    name: str
    pip: str
    env: Dict[str, str]

    def __init__(self, name: str, pip: str):
        super().__init__(name)
        self.name = name
        self.pip = pip
        self.env = environ.copy()
        self.env['PYTHONWARNINGS'] = 'ignore:DEPRECATION'

    async def check_packages(self) -> Updates:
        self.update_status("Checking for outdated packages...")
        output = await run(
            f"{self.pip} list -o", env=self.env
        )
        lines = output.stdout.splitlines()[2:]
        packages: List[Package] = []
        for line in lines:
            parts = line.split()
            packages.append(Package(parts[0], parts[1], parts[2]))
        self.update_status("Done")
        return Updates(self.name, packages)

    async def update_package(self, pkg_name: str):
        out = await run(
            f"{self.pip} install -U {pkg_name}",
            env=self.env
        )
        return out.exitcode == 0


class BrewUpdater(Updater):
    brew_cmd: str

    def __init__(self, cask: bool = False):
        super().__init__("cask" if cask else "brew")
        self.brew_cmd = f"brew{' cask' if cask else ''}"

    async def check_packages(self) -> Updates:
        self.update_status("Updating cache...")
        await run("brew update")

        self.update_status("Checking for outdated packages...")
        output = await run(f"{self.brew_cmd} outdated -v")

        lines = output.stdout.splitlines()
        packages: List[Package] = []

        for line in lines:
            parts = line.split()
            name = parts[0]
            previous = parts[1].strip("()")
            current = parts[3]
            packages.append(Package(name, previous, current))

        self.update_status("Done")
        return Updates(self.name, packages)

    async def update_package(self, pkg_name: str):
        out = await run(f"{self.brew_cmd} upgrade {pkg_name}")
        if self.brew_cmd == 'brew' and out.exitcode == 0:
            await run(f"brew cleanup {pkg_name}")
        return out.exitcode == 0


class NpmUpdater(Updater):
    def __init__(self):
        super().__init__("npm")

    async def check_packages(self) -> Updates:
        self.update_status("Checking for outdated packages...")
        output = await run(
            "npm --registry=https://registry.npmjs.org outdated -g --parseable"
        )

        lines = output.stdout.splitlines()
        packages: List[Package] = []

        for line in lines:
            parts = line.split(":")
            name = parts[1].rpartition("@")[0]
            current = parts[1].rpartition("@")[2]
            latest = parts[3].rpartition("@")[2]
            packages.append(Package(name, current, latest))

        return Updates("npm", packages)

    async def update_package(self, pkg_name: str):
        out = await run(
            f"npm install --registry=https://registry.npmjs.org --progress=false -g {pkg_name}@latest"
        )
        return out.exitcode == 0


def format_status(tag: str, status: str) -> str:
    return f"[{tag:>4}] {status}"


def add_status(tag: str, status: str) -> StatusUpdater:
    index = len(statuses)

    def updater(status: str):
        update_status(index, status)

    statuses.append(tag)
    stdout.buffer.write(f"{format_status(tag, status)}\n".encode("utf-8"))
    stdout.flush()
    return updater


def update_status(index: int, status: str):
    tag = statuses[index]
    stdout.buffer.write(
        b"".join(
            [
                # save cursor position
                tparm(tigetstr("sc")),
                # move to proper line
                tparm(tigetstr("cuu"), len(statuses) - index),
                # move to first column
                tparm(tigetstr("cub"), num_cols),
                # print new status
                format_status(tag, status).encode("utf-8"),
                # clear line
                tparm(tigetstr("el")),
                # restore cursor position
                tparm(tigetstr("rc")),
            ]
        )
    )
    stdout.flush()


async def run(cmd: str, **kwargs) -> Output:
    proc = await asyncio.create_subprocess_shell(
        cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE, **kwargs
    )
    (stdout, stderr) = await proc.communicate()
    return Output(proc.returncode, stdout, stderr)


async def main():
    parser = ArgumentParser()
    parser.add_argument(
        "--dry-run", "-n", action="store_true", help="Show what would be updated"
    )
    parser.add_argument(
        "groups", metavar="GROUP", type=str, nargs="*", help="Package groups to update"
    )
    args = parser.parse_args()

    groups = args.groups
    if len(groups) == 0:
        groups.append("brew")
        groups.append("cask")
        groups.append("npm")
        groups.append("vim")
        groups.append("zsh")
        groups.append("py2")
        groups.append("py3")

        if getenv("TMUX_PLUGIN_MANAGER_PATH"):
            groups.append("tmux")

    updaters = []

    # If we're updating brew packages, do that first, because later updates may depend
    # on updated brew packages
    if "brew" in groups:
        groups.remove("brew")
        updater = BrewUpdater()
        if args.dry_run:
            await updater.check_packages()
        else:
            await updater.update_packages()

    for group in groups:
        if group == "npm":
            updaters.append(NpmUpdater())
        elif group == "cask":
            updaters.append(BrewUpdater(cask=True))
        elif group == "tmux":
            updaters.append(
                GitUpdater("tmux", Path(getenv("TMUX_PLUGIN_MANAGER_PATH")))
            )
        elif group == "vim":
            updaters.append(
                GitUpdater("vim", Path(getenv("CACHEDIR")) / "vim" / "plugins")
            )
        elif group == "zsh":
            updaters.append(
                GitUpdater("zsh", Path(getenv("CACHEDIR")) / "zsh" / "plugins")
            )
        elif group == "py2":
            updaters.append(PythonUpdater("py2", "pip2"))
        elif group == "py3":
            updaters.append(PythonUpdater("py3", "pip3"))

    if args.dry_run:
        tasks = [u.check_packages() for u in updaters]
    else:
        tasks = [u.update_packages() for u in updaters]

    updates = await asyncio.gather(*tasks)

    print()

    for i, update in enumerate(updates):
        print(update.name)
        if len(update.packages) > 0:
            for pkg in update.packages:
                print(f"  {pkg.name}: {pkg.previous} -> {pkg.current}")
        else:
            print("  No updates")

        if i < len(updates) - 1:
            print()


setupterm()
num_cols = tigetnum("cols")
asyncio.run(main())
